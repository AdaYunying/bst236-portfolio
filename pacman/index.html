<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man: Valentine's Edition ğŸ’˜</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Rajdhani:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a12;
            color: #e0e0f0;
            font-family: 'Rajdhani', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .back-link {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff69b4;
            text-decoration: none;
            font-size: 14px;
            transition: all 0.3s ease;
            z-index: 100;
        }

        .back-link:hover {
            color: #00f0ff;
            text-shadow: 0 0 10px #00f0ff;
        }

        h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 1.8em;
            margin-top: 40px;
            margin-bottom: 30px;
            text-align: center;
            background: linear-gradient(90deg, #ff69b4, #ff1493, #ff69b4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1.4;
        }

        .game-container {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            justify-content: center;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .instructions-panel {
            width: 280px;
            background: rgba(12, 12, 25, 0.8);
            border: 1px solid rgba(255, 105, 180, 0.3);
            border-radius: 10px;
            padding: 20px;
            color: #e0e0f0;
        }

        .instructions-panel h3 {
            color: #ff69b4;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
        }

        .instruction-item {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: flex-start;
        }

        .instruction-icon {
            font-size: 28px;
            min-width: 35px;
            text-align: center;
        }

        .instruction-content strong {
            display: block;
            color: #00f0ff;
            font-size: 1em;
            margin-bottom: 5px;
        }

        .instruction-content p {
            font-size: 0.9em;
            color: #b0b0c0;
            margin: 3px 0;
            line-height: 1.4;
        }

        .instruction-divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 105, 180, 0.3), transparent);
            margin: 15px 0;
        }

        #gameCanvas {
            border: 2px solid #ff69b4;
            box-shadow: 0 0 20px rgba(255, 105, 180, 0.3);
            background: #0a0a12;
        }

        .ui-panel {
            display: flex;
            gap: 40px;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            padding: 15px 30px;
            background: rgba(12, 12, 25, 0.8);
            border: 1px solid rgba(255, 105, 180, 0.3);
            border-radius: 10px;
            min-width: 560px;
        }

        .score, .lives {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .score-label, .lives-label {
            color: #ff69b4;
            font-weight: bold;
        }

        .score-value {
            color: #00f0ff;
            font-weight: bold;
            font-size: 24px;
        }

        .hearts {
            display: flex;
            gap: 5px;
            font-size: 20px;
        }

        .power-timer {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 150px;
        }

        .power-timer-label {
            color: #ff69b4;
            font-size: 14px;
        }

        .power-timer-bar {
            width: 100%;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            overflow: hidden;
        }

        .power-timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff69b4, #ff1493);
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px #ff69b4;
        }
    </style>
</head>
<body>
    <a href="../index.html" class="back-link">â† Back to Home</a>

    <h1>Pac-Man: Valentine's Edition ğŸ’˜</h1>

    <div class="game-container">
        <div class="game-area">
            <canvas id="gameCanvas" width="560" height="620"></canvas>

            <div class="ui-panel">
                <div class="score">
                    <span class="score-label">Score:</span>
                    <span class="score-value" id="scoreDisplay">0</span>
                </div>
                <div class="lives">
                    <span class="lives-label">Lives:</span>
                    <div class="hearts" id="heartsDisplay"></div>
                </div>
                <div class="power-timer" id="powerTimer" style="visibility: hidden;">
                    <span class="power-timer-label">Power-Up</span>
                    <div class="power-timer-bar">
                        <div class="power-timer-fill" id="powerTimerFill"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="instructions-panel">
            <h3>ğŸ® How to Play</h3>

            <div class="instruction-item">
                <div class="instruction-icon">âŒ¨ï¸</div>
                <div class="instruction-content">
                    <strong>Controls</strong>
                    <p>â†‘ â†“ â† â†’ Arrow Keys - Move</p>
                    <p>P / ESC - Pause</p>
                    <p>Q - Quit (when paused)</p>
                </div>
            </div>

            <div class="instruction-divider"></div>

            <div class="instruction-item">
                <div class="instruction-icon">ğŸ¯</div>
                <div class="instruction-content">
                    <strong>Objectives</strong>
                    <p>Eat all white pellets to win</p>
                    <p>Avoid ghosts (or eat them!)</p>
                    <p>Score as many points as you can</p>
                </div>
            </div>


            <div class="instruction-divider"></div>

            <div class="instruction-item">
                <div class="instruction-icon">ğŸŒ¹</div>
                <div class="instruction-content">
                    <strong>Power-Up (8s)</strong>
                    <p>Collect roses for power mode</p>
                    <p>Shoot hearts automatically</p>
                    <p>Eat ghosts on contact!</p>
                </div>
            </div>

            <div class="instruction-divider"></div>

            <!-- <div class="instruction-item">
                <div class="instruction-icon">ğŸ‘»</div>
                <div class="instruction-content">
                    <strong>Ghosts</strong>
                    <p>ğŸ”´ Red - Chases you directly</p>
                    <p>ğŸ”µ Cyan - Ambushes ahead</p>
                    <p>ğŸŸ  Orange - Moves randomly</p>
                </div>
            </div> -->

            <div class="instruction-divider"></div>

            <div class="instruction-item">
                <div class="instruction-icon">ğŸ’¯</div>
                <div class="instruction-content">
                    <strong>Scoring</strong>
                    <p>Pellet: 10 pts</p>
                    <p>Rose: 50 pts</p>
                    <p>Ghost: 200 pts</p>
                    <p>Win bonus: 1000 pts</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const heartsDisplay = document.getElementById('heartsDisplay');
        const powerTimer = document.getElementById('powerTimer');
        const powerTimerFill = document.getElementById('powerTimerFill');

        // æ¸¸æˆå¸¸é‡
        const TILE_SIZE = 20;
        const MAZE_WIDTH = 28;
        const MAZE_HEIGHT = 31;
        const PACMAN_SPEED = 0.15;  // æ¯æ¯«ç§’ç§»åŠ¨åƒç´ æ•° (çº¦90åƒç´ /ç§’)
        const GHOST_SPEED = 0.09;   // æ¯æ¯«ç§’ç§»åŠ¨åƒç´ æ•° (çº¦54åƒç´ /ç§’)
        const HEART_SPEED = 0.3;    // æ¯æ¯«ç§’ç§»åŠ¨åƒç´ æ•° (çº¦180åƒç´ /ç§’)
        const POWER_UP_DURATION = 8000;
        const ROSE_SPAWN_MIN = 10000;  // æå‰å‡ºç°ï¼š15000 -> 10000
        const ROSE_SPAWN_MAX = 15000;  // è°ƒæ•´ï¼š20000 -> 15000
        const ROSE_DESPAWN = 10000;
        const HEART_FIRE_INTERVAL = 500;

        // è¿·å®«å¸ƒå±€ (0=å¢™, 1=è·¯å¾„+è±†å­, 2=è·¯å¾„æ— è±†å­, 3=é¬¼å±‹)
        const ORIGINAL_MAZE = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
            [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
            [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
            [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0],
            [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
            [0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,0,0,0,2,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,2,2,2,2,2,2,2,2,2,2,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,2,0,0,0,3,3,0,0,0,2,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,2,0,3,3,3,3,3,3,0,2,0,0,1,0,0,0,0,0,0],
            [2,2,2,2,2,2,1,2,2,2,0,3,3,3,3,3,3,0,2,2,2,1,2,2,2,2,2,2],
            [0,0,0,0,0,0,1,0,0,2,0,3,3,3,3,3,3,0,2,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,2,2,2,2,2,2,2,2,2,2,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
            [0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0],
            [0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0],
            [0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
            [0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0],
            [0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0],
            [0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],
            [0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
        ];

        // å·¥ä½œå‰¯æœ¬ï¼ˆä¼šè¢«ä¿®æ”¹ï¼‰
        let maze = [];

        // æ¸¸æˆçŠ¶æ€
        let gameState = {
            screen: 'start', // start, playing, gameover, win
            score: 0,
            lives: 5,
            pelletsRemaining: 0,
            frame: 0,
            lastTime: 0
        };

        // åƒè±†äºº
        let pacman = {
            gridX: 14,
            gridY: 23,
            pixelX: 14 * TILE_SIZE,
            pixelY: 23 * TILE_SIZE,
            direction: 'right',
            nextDirection: null,
            speed: PACMAN_SPEED,
            mouthAngle: 0,
            mouthOpen: true,
            powered: false,
            powerEndTime: 0,     // èƒ½é‡ç»“æŸçš„ç»å¯¹æ—¶é—´æˆ³
            lastHeartTime: 0
        };

        // é¬¼é­‚
        let ghosts = [
            {
                name: 'red',
                color: '#FF0000',
                gridX: 14,
                gridY: 14,
                pixelX: 14 * TILE_SIZE,
                pixelY: 14 * TILE_SIZE,
                direction: 'up',
                speed: GHOST_SPEED,
                aiType: 'chase',
                mode: 'leaving',  // åˆå§‹çŠ¶æ€ï¼šç¦»å¼€é¬¼å±‹
                respawnTimer: 0
            },
            {
                name: 'cyan',
                color: '#00FFFF',
                gridX: 13,
                gridY: 14,
                pixelX: 13 * TILE_SIZE,
                pixelY: 14 * TILE_SIZE,
                direction: 'up',
                speed: GHOST_SPEED,
                aiType: 'ambush',
                mode: 'leaving',  // åˆå§‹çŠ¶æ€ï¼šç¦»å¼€é¬¼å±‹
                respawnTimer: 1000
            },
            {
                name: 'orange',
                color: '#FFA500',
                gridX: 15,
                gridY: 14,
                pixelX: 15 * TILE_SIZE,
                pixelY: 14 * TILE_SIZE,
                direction: 'up',
                speed: GHOST_SPEED,
                aiType: 'random',
                mode: 'leaving',  // åˆå§‹çŠ¶æ€ï¼šç¦»å¼€é¬¼å±‹
                respawnTimer: 2000
            }
        ];

        // ç«ç‘°é“å…·
        let rose = {
            active: false,
            gridX: 0,
            gridY: 0,
            spawnTimer: ROSE_SPAWN_MIN + Math.random() * (ROSE_SPAWN_MAX - ROSE_SPAWN_MIN),
            despawnTimer: 0,
            glowPhase: 0
        };

        // å¿ƒå½¢æŠ•å°„ç‰©æ•°ç»„
        let hearts = [];

        // æ–¹å‘å‘é‡
        const DIRECTIONS = {
            'up': { x: 0, y: -1 },
            'down': { x: 0, y: 1 },
            'left': { x: -1, y: 0 },
            'right': { x: 1, y: 0 }
        };

        // é‡ç½®è¿·å®«ï¼ˆæ¢å¤æ‰€æœ‰è±†å­ï¼‰
        function resetMaze() {
            // æ·±æ‹·è´åŸå§‹è¿·å®«
            maze = ORIGINAL_MAZE.map(row => [...row]);

            // é‡æ–°è®¡ç®—è±†å­æ•°é‡
            gameState.pelletsRemaining = 0;
            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 1) {
                        gameState.pelletsRemaining++;
                    }
                }
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function init() {
            // åˆå§‹åŒ–è¿·å®«
            resetMaze();

            updateUI();
            gameLoop(0);
        }

        // æ›´æ–°UIæ˜¾ç¤º
        function updateUI() {
            scoreDisplay.textContent = gameState.score;
            heartsDisplay.innerHTML = 'â¤ï¸'.repeat(gameState.lives);

            if (pacman.powered) {
                powerTimer.style.visibility = 'visible';
                const remaining = Math.max(0, pacman.powerEndTime - Date.now());
                const percent = (remaining / POWER_UP_DURATION) * 100;
                powerTimerFill.style.width = percent + '%';
            } else {
                powerTimer.style.visibility = 'hidden';
            }
        }

        // é”®ç›˜è¾“å…¥
        document.addEventListener('keydown', (e) => {
            if (gameState.screen === 'start' && e.key === 'Enter') {
                startGame();
            } else if ((gameState.screen === 'gameover' || gameState.screen === 'win') && e.key === 'Enter') {
                restartGame();
            } else if (gameState.screen === 'playing') {
                // æš‚åœ
                if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
                    e.preventDefault();
                    gameState.screen = 'paused';
                }
                // æ–¹å‘æ§åˆ¶
                else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    pacman.nextDirection = 'up';
                } else if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    pacman.nextDirection = 'down';
                } else if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    pacman.nextDirection = 'left';
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    pacman.nextDirection = 'right';
                }
            } else if (gameState.screen === 'paused') {
                // æ¢å¤æ¸¸æˆ
                if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
                    e.preventDefault();
                    gameState.screen = 'playing';
                }
                // é€€å‡ºåˆ°å¼€å§‹å±å¹•
                else if (e.key === 'q' || e.key === 'Q') {
                    e.preventDefault();
                    gameState.screen = 'start';
                }
            }
        });

        // é¼ æ ‡ç‚¹å‡»
        canvas.addEventListener('click', () => {
            if (gameState.screen === 'start') {
                startGame();
            } else if (gameState.screen === 'gameover' || gameState.screen === 'win') {
                restartGame();
            }
        });

        // å¼€å§‹æ¸¸æˆ
        function startGame() {
            gameState.screen = 'playing';
            gameState.score = 0;
            gameState.lives = 5;

            // é‡ç½®è¿·å®«ï¼ˆæ¢å¤æ‰€æœ‰è±†å­ï¼‰
            resetMaze();

            resetPositions();
            updateUI();
        }

        // é‡ç½®ä½ç½®
        function resetPositions() {
            pacman.gridX = 14;
            pacman.gridY = 23;
            pacman.pixelX = 14 * TILE_SIZE;
            pacman.pixelY = 23 * TILE_SIZE;
            pacman.direction = 'right';
            pacman.nextDirection = null;
            pacman.powered = false;
            pacman.powerEndTime = 0;

            ghosts[0].gridX = 14;
            ghosts[0].gridY = 14;
            ghosts[0].pixelX = 14 * TILE_SIZE;
            ghosts[0].pixelY = 14 * TILE_SIZE;
            ghosts[0].mode = 'leaving';

            ghosts[1].gridX = 13;
            ghosts[1].gridY = 14;
            ghosts[1].pixelX = 13 * TILE_SIZE;
            ghosts[1].pixelY = 14 * TILE_SIZE;
            ghosts[1].mode = 'leaving';

            ghosts[2].gridX = 15;
            ghosts[2].gridY = 14;
            ghosts[2].pixelX = 15 * TILE_SIZE;
            ghosts[2].pixelY = 14 * TILE_SIZE;
            ghosts[2].mode = 'leaving';

            hearts = [];
        }

        // é‡æ–°å¼€å§‹
        function restartGame() {
            startGame();
        }

        // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç§»åŠ¨åˆ°æŸä¸ªæ ¼å­
        function canMove(gridX, gridY) {
            // å¤„ç†éš§é“ç¯ç»•
            let x = gridX;
            let y = gridY;

            if (x < 0) x = MAZE_WIDTH - 1;
            if (x >= MAZE_WIDTH) x = 0;
            if (y < 0) y = MAZE_HEIGHT - 1;
            if (y >= MAZE_HEIGHT) y = 0;

            return maze[y][x] !== 0;
        }

        // æ£€æŸ¥å®ä½“æ˜¯å¦åœ¨ç½‘æ ¼ä¸­å¿ƒ
        function isAtGridCenter(entity) {
            const targetX = entity.gridX * TILE_SIZE;
            const targetY = entity.gridY * TILE_SIZE;
            return Math.abs(entity.pixelX - targetX) < 1 && Math.abs(entity.pixelY - targetY) < 1;
        }

        // æ›´æ–°åƒè±†äºº
        function updatePacman(deltaTime) {
            const targetX = pacman.gridX * TILE_SIZE;
            const targetY = pacman.gridY * TILE_SIZE;

            // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç›®æ ‡ï¼ˆå¢åŠ å®¹å·®é˜²æ­¢æµ®ç‚¹è¯¯å·®ï¼‰
            const tolerance = 0.5;
            const reachedX = Math.abs(pacman.pixelX - targetX) < tolerance;
            const reachedY = Math.abs(pacman.pixelY - targetY) < tolerance;

            // å¦‚æœè¿˜åœ¨ç§»åŠ¨ä¸­ï¼Œç»§ç»­ç§»åŠ¨
            if (!reachedX || !reachedY) {
                const movement = pacman.speed * deltaTime;
                if (!reachedX) {
                    if (pacman.pixelX < targetX) {
                        pacman.pixelX = Math.min(pacman.pixelX + movement, targetX);
                    } else {
                        pacman.pixelX = Math.max(pacman.pixelX - movement, targetX);
                    }
                }

                if (!reachedY) {
                    if (pacman.pixelY < targetY) {
                        pacman.pixelY = Math.min(pacman.pixelY + movement, targetY);
                    } else {
                        pacman.pixelY = Math.max(pacman.pixelY - movement, targetY);
                    }
                }
                return; // è¿˜åœ¨ç§»åŠ¨ä¸­ï¼Œä¸åšå…¶ä»–å¤„ç†
            }

            // å®Œå…¨åˆ°è¾¾ç›®æ ‡ï¼Œå¼ºåˆ¶å¯¹é½ï¼ˆé˜²æ­¢æµ®ç‚¹è¯¯å·®ç´¯ç§¯ï¼‰
            pacman.pixelX = targetX;
            pacman.pixelY = targetY;

            // å°è¯•åº”ç”¨ç¼“å†²çš„æ–¹å‘
            if (pacman.nextDirection) {
                const dir = DIRECTIONS[pacman.nextDirection];
                if (canMove(pacman.gridX + dir.x, pacman.gridY + dir.y)) {
                    pacman.direction = pacman.nextDirection;
                    pacman.nextDirection = null;
                }
            }

            // ç»§ç»­å½“å‰æ–¹å‘ç§»åŠ¨
            const dir = DIRECTIONS[pacman.direction];
            let nextX = pacman.gridX + dir.x;
            let nextY = pacman.gridY + dir.y;

            // éš§é“ç¯ç»•
            if (nextX < 0) nextX = MAZE_WIDTH - 1;
            if (nextX >= MAZE_WIDTH) nextX = 0;
            if (nextY < 0) nextY = MAZE_HEIGHT - 1;
            if (nextY >= MAZE_HEIGHT) nextY = 0;

            if (canMove(nextX, nextY)) {
                pacman.gridX = nextX;
                pacman.gridY = nextY;
            }

            // å˜´å·´åŠ¨ç”»
            pacman.mouthAngle += 0.15;
            if (pacman.mouthAngle > Math.PI * 2) {
                pacman.mouthAngle = 0;
            }

            // èƒ½é‡çŠ¶æ€æ›´æ–°ï¼ˆä½¿ç”¨ç»å¯¹æ—¶é—´ï¼‰
            if (pacman.powered) {
                const now = Date.now();

                // æ£€æŸ¥èƒ½é‡æ˜¯å¦è¿‡æœŸ
                if (now >= pacman.powerEndTime) {
                    pacman.powered = false;
                    pacman.powerEndTime = 0;
                } else {
                    // å‘å°„å¿ƒå½¢
                    if (now - pacman.lastHeartTime > HEART_FIRE_INTERVAL) {
                        shootHeart();
                        pacman.lastHeartTime = now;
                    }
                }
            }
        }

        // æ›´æ–°é¬¼é­‚
        function updateGhost(ghost, deltaTime) {
            // å¦‚æœåœ¨å¤æ´»ä¸­
            if (ghost.respawnTimer > 0) {
                ghost.respawnTimer -= deltaTime;
                return;
            }

            // å¦‚æœå¤„äºç¦»å¼€é¬¼å±‹çŠ¶æ€
            if (ghost.mode === 'leaving') {
                const targetX = ghost.gridX * TILE_SIZE;
                const targetY = ghost.gridY * TILE_SIZE;
                const movement = ghost.speed * deltaTime;

                // ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
                if (ghost.pixelX < targetX) {
                    ghost.pixelX = Math.min(ghost.pixelX + movement, targetX);
                } else if (ghost.pixelX > targetX) {
                    ghost.pixelX = Math.max(ghost.pixelX - movement, targetX);
                }

                if (ghost.pixelY < targetY) {
                    ghost.pixelY = Math.min(ghost.pixelY + movement, targetY);
                } else if (ghost.pixelY > targetY) {
                    ghost.pixelY = Math.max(ghost.pixelY - movement, targetY);
                }

                if (isAtGridCenter(ghost)) {
                    ghost.pixelX = targetX;
                    ghost.pixelY = targetY;

                    // å…ˆç§»åŠ¨åˆ°ä¸­å¿ƒ X=14
                    if (ghost.gridX < 14) {
                        ghost.direction = 'right';
                        ghost.gridX++;
                    } else if (ghost.gridX > 14) {
                        ghost.direction = 'left';
                        ghost.gridX--;
                    } else {
                        // X å·²å¯¹é½ï¼Œå‘ä¸Šç§»åŠ¨
                        ghost.direction = 'up';

                        // åˆ°è¾¾å‡ºå£ï¼ˆY=11ï¼‰æ—¶åˆ‡æ¢åˆ°è¿½é€æ¨¡å¼
                        if (ghost.gridY <= 11) {
                            ghost.mode = 'chase';
                        } else {
                            ghost.gridY--;
                        }
                    }
                }
                return;
            }

            // å¦‚æœå¤„äºè¿”å›é¬¼å±‹çŠ¶æ€
            if (ghost.mode === 'eaten') {
                const targetX = ghost.gridX * TILE_SIZE;
                const targetY = ghost.gridY * TILE_SIZE;
                const movement = ghost.speed * deltaTime * 2; // è¢«åƒæ‰åç§»åŠ¨æ›´å¿«

                // ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
                if (ghost.pixelX < targetX) {
                    ghost.pixelX = Math.min(ghost.pixelX + movement, targetX);
                } else if (ghost.pixelX > targetX) {
                    ghost.pixelX = Math.max(ghost.pixelX - movement, targetX);
                }

                if (ghost.pixelY < targetY) {
                    ghost.pixelY = Math.min(ghost.pixelY + movement, targetY);
                } else if (ghost.pixelY > targetY) {
                    ghost.pixelY = Math.max(ghost.pixelY - movement, targetY);
                }

                if (isAtGridCenter(ghost)) {
                    if (ghost.gridX === 14 && ghost.gridY === 14) {
                        ghost.mode = 'leaving';  // å¤æ´»åé‡æ–°ç¦»å¼€é¬¼å±‹
                        ghost.respawnTimer = 3000;
                    } else {
                        // æœé¬¼å±‹ç§»åŠ¨
                        ghost.direction = getDirectionTo(ghost, { gridX: 14, gridY: 14 });
                        const dir = DIRECTIONS[ghost.direction];
                        ghost.gridX += dir.x;
                        ghost.gridY += dir.y;
                    }
                }
                return;
            }

            const targetX = ghost.gridX * TILE_SIZE;
            const targetY = ghost.gridY * TILE_SIZE;
            const movement = ghost.speed * deltaTime;

            // ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
            if (ghost.pixelX < targetX) {
                ghost.pixelX = Math.min(ghost.pixelX + movement, targetX);
            } else if (ghost.pixelX > targetX) {
                ghost.pixelX = Math.max(ghost.pixelX - movement, targetX);
            }

            if (ghost.pixelY < targetY) {
                ghost.pixelY = Math.min(ghost.pixelY + movement, targetY);
            } else if (ghost.pixelY > targetY) {
                ghost.pixelY = Math.max(ghost.pixelY - movement, targetY);
            }

            // åˆ°è¾¾ç½‘æ ¼ä¸­å¿ƒæ—¶é€‰æ‹©æ–°æ–¹å‘
            if (isAtGridCenter(ghost)) {
                ghost.pixelX = targetX;
                ghost.pixelY = targetY;

                // AIé€»è¾‘
                if (ghost.aiType === 'chase') {
                    ghost.direction = getDirectionTo(ghost, pacman);
                } else if (ghost.aiType === 'ambush') {
                    const target = getAmbushTarget();
                    ghost.direction = getDirectionTo(ghost, target);
                } else if (ghost.aiType === 'random') {
                    ghost.direction = getRandomDirection(ghost);
                }

                const dir = DIRECTIONS[ghost.direction];
                let nextX = ghost.gridX + dir.x;
                let nextY = ghost.gridY + dir.y;

                // éš§é“ç¯ç»•
                if (nextX < 0) nextX = MAZE_WIDTH - 1;
                if (nextX >= MAZE_WIDTH) nextX = 0;
                if (nextY < 0) nextY = MAZE_HEIGHT - 1;
                if (nextY >= MAZE_HEIGHT) nextY = 0;

                if (canMove(nextX, nextY)) {
                    ghost.gridX = nextX;
                    ghost.gridY = nextY;
                }
            }
        }

        // è·å–æœå‘ç›®æ ‡çš„æ–¹å‘
        function getDirectionTo(entity, target) {
            const directions = ['up', 'down', 'left', 'right'];
            const opposite = {
                'up': 'down',
                'down': 'up',
                'left': 'right',
                'right': 'left'
            };

            let bestDir = entity.direction;
            let minDist = Infinity;

            directions.forEach(dir => {
                if (dir === opposite[entity.direction]) return; // ä¸èµ°å›å¤´è·¯

                const dv = DIRECTIONS[dir];
                const nextX = entity.gridX + dv.x;
                const nextY = entity.gridY + dv.y;

                if (canMove(nextX, nextY)) {
                    const dist = Math.abs(nextX - target.gridX) + Math.abs(nextY - target.gridY);
                    if (dist < minDist) {
                        minDist = dist;
                        bestDir = dir;
                    }
                }
            });

            return bestDir;
        }

        // è·å–ä¼å‡»ç›®æ ‡ç‚¹
        function getAmbushTarget() {
            const dir = DIRECTIONS[pacman.direction];
            return {
                gridX: pacman.gridX + dir.x * 4,
                gridY: pacman.gridY + dir.y * 4
            };
        }

        // è·å–éšæœºæ–¹å‘
        function getRandomDirection(entity) {
            const directions = ['up', 'down', 'left', 'right'];
            const opposite = {
                'up': 'down',
                'down': 'up',
                'left': 'right',
                'right': 'left'
            };

            const validDirs = directions.filter(dir => {
                if (dir === opposite[entity.direction]) return false;
                const dv = DIRECTIONS[dir];
                return canMove(entity.gridX + dv.x, entity.gridY + dv.y);
            });

            if (validDirs.length === 0) return entity.direction;
            return validDirs[Math.floor(Math.random() * validDirs.length)];
        }

        // æ›´æ–°ç«ç‘°
        function updateRose(deltaTime) {
            if (!rose.active) {
                rose.spawnTimer -= deltaTime;
                if (rose.spawnTimer <= 0) {
                    spawnRose();
                }
            } else {
                rose.despawnTimer -= deltaTime;
                rose.glowPhase += 0.05;

                if (rose.despawnTimer <= 0) {
                    rose.active = false;
                    rose.spawnTimer = ROSE_SPAWN_MIN + Math.random() * (ROSE_SPAWN_MAX - ROSE_SPAWN_MIN);
                }
            }
        }

        // ç”Ÿæˆç«ç‘°
        function spawnRose() {
            const validTiles = [];
            for (let y = 1; y < MAZE_HEIGHT - 1; y++) {  // é¿å¼€è¾¹ç¼˜
                for (let x = 1; x < MAZE_WIDTH - 1; x++) {
                    if ((maze[y][x] === 1 || maze[y][x] === 2) &&
                        // ç¡®ä¿ç¦»åƒè±†äººè‡³å°‘5æ ¼è¿œ
                        Math.abs(x - pacman.gridX) + Math.abs(y - pacman.gridY) > 5) {
                        validTiles.push({ x, y });
                    }
                }
            }

            if (validTiles.length > 0) {
                const tile = validTiles[Math.floor(Math.random() * validTiles.length)];
                rose.gridX = tile.x;
                rose.gridY = tile.y;
                rose.active = true;
                rose.despawnTimer = ROSE_DESPAWN;
                console.log('ğŸŒ¹ ç«ç‘°ç”Ÿæˆï¼ä½ç½®:', rose.gridX, rose.gridY);
            } else {
                console.log('âš ï¸ æ²¡æœ‰åˆé€‚çš„ä½ç½®ç”Ÿæˆç«ç‘°');
            }
        }

        // æ”¶é›†ç«ç‘°
        function collectRose() {
            rose.active = false;
            rose.spawnTimer = ROSE_SPAWN_MIN + Math.random() * (ROSE_SPAWN_MAX - ROSE_SPAWN_MIN);

            // å¼ºåˆ¶å¯¹é½åˆ°ç½‘æ ¼ä¸­å¿ƒï¼ˆé˜²æ­¢ç©¿å¢™bugï¼‰
            pacman.pixelX = pacman.gridX * TILE_SIZE;
            pacman.pixelY = pacman.gridY * TILE_SIZE;

            // ä½¿ç”¨ç»å¯¹æ—¶é—´
            const now = Date.now();
            pacman.powered = true;
            pacman.powerEndTime = now + POWER_UP_DURATION;
            pacman.lastHeartTime = now;

            gameState.score += 50;
            console.log('ğŸ’– æ”¶é›†ç«ç‘°ï¼èƒ½é‡æ¨¡å¼æ¿€æ´»8ç§’');
        }

        // å‘å°„å¿ƒå½¢
        function shootHeart() {
            hearts.push({
                pixelX: pacman.pixelX + TILE_SIZE / 2,
                pixelY: pacman.pixelY + TILE_SIZE / 2,
                direction: pacman.direction,
                speed: HEART_SPEED,
                trail: []
            });
        }

        // æ›´æ–°å¿ƒå½¢
        function updateHearts(deltaTime) {
            for (let i = hearts.length - 1; i >= 0; i--) {
                const heart = hearts[i];
                const dir = DIRECTIONS[heart.direction];
                const movement = heart.speed * deltaTime;

                heart.pixelX += dir.x * movement;
                heart.pixelY += dir.y * movement;

                // æ‹–å°¾æ•ˆæœ
                heart.trail.unshift({ x: heart.pixelX, y: heart.pixelY });
                if (heart.trail.length > 5) {
                    heart.trail.pop();
                }

                // æ£€æŸ¥ç¢°æ’å¢™å£
                const gridX = Math.floor(heart.pixelX / TILE_SIZE);
                const gridY = Math.floor(heart.pixelY / TILE_SIZE);

                if (!canMove(gridX, gridY)) {
                    hearts.splice(i, 1);
                    continue;
                }

                // æ£€æŸ¥ç¢°æ’é¬¼é­‚
                let hitGhost = false;
                ghosts.forEach(ghost => {
                    if (ghost.mode !== 'eaten' && ghost.respawnTimer <= 0) {
                        const dist = Math.sqrt(
                            Math.pow(heart.pixelX - (ghost.pixelX + TILE_SIZE / 2), 2) +
                            Math.pow(heart.pixelY - (ghost.pixelY + TILE_SIZE / 2), 2)
                        );

                        if (dist < TILE_SIZE) {
                            ghost.mode = 'eaten';
                            gameState.score += 200;
                            hitGhost = true;
                        }
                    }
                });

                if (hitGhost) {
                    hearts.splice(i, 1);
                }
            }
        }

        // ç¢°æ’æ£€æµ‹
        function checkCollisions() {
            // åƒè±†å­
            if (maze[pacman.gridY][pacman.gridX] === 1) {
                maze[pacman.gridY][pacman.gridX] = 2;
                gameState.score += 10;
                gameState.pelletsRemaining--;

                if (gameState.pelletsRemaining === 0) {
                    gameState.score += 1000;
                    gameState.screen = 'win';
                }
            }

            // ç¢°åˆ°ç«ç‘°
            if (rose.active && rose.gridX === pacman.gridX && rose.gridY === pacman.gridY) {
                collectRose();
            }

            // ç¢°åˆ°é¬¼é­‚
            ghosts.forEach(ghost => {
                if (ghost.mode !== 'eaten' && ghost.respawnTimer <= 0) {
                    // ä½¿ç”¨åƒç´ ä½ç½®è®¡ç®—è·ç¦»ï¼Œè€Œä¸æ˜¯ç½‘æ ¼ä½ç½®
                    const dx = pacman.pixelX - ghost.pixelX;
                    const dy = pacman.pixelY - ghost.pixelY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // å¦‚æœè·ç¦»å°äºä¸€ä¸ªç½‘æ ¼çš„å¤§å°ï¼Œå°±ç®—ç¢°æ’
                    if (distance < TILE_SIZE * 0.8) {  // ç¨å¾®å®½æ¾ä¸€ç‚¹ï¼Œé¿å…å¤ªæ•æ„Ÿ
                        if (pacman.powered) {
                            // èƒ½é‡æ¨¡å¼ï¼šæ¶ˆç­å¹½çµ
                            ghost.mode = 'eaten';
                            gameState.score += 200;
                            console.log('ğŸ‘» æ¶ˆç­äº†', ghost.name, 'å¹½çµï¼+200åˆ†');
                        } else {
                            // æ­£å¸¸æ¨¡å¼ï¼šåƒè±†äººæ­»
                            pacmanDie();
                        }
                    }
                }
            });
        }

        // åƒè±†äººæ­»äº¡
        function pacmanDie() {
            gameState.lives--;

            if (gameState.lives <= 0) {
                gameState.screen = 'gameover';
            } else {
                resetPositions();
            }

            updateUI();
        }

        // æ¸²æŸ“è¿·å®«
        function renderMaze() {
            ctx.strokeStyle = '#ff69b4';
            ctx.lineWidth = 2;

            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 0) {
                        ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }

        // æ¸²æŸ“è±†å­
        function renderPellets() {
            ctx.fillStyle = '#FFFFFF';

            for (let y = 0; y < MAZE_HEIGHT; y++) {
                for (let x = 0; x < MAZE_WIDTH; x++) {
                    if (maze[y][x] === 1) {
                        ctx.beginPath();
                        ctx.arc(
                            x * TILE_SIZE + TILE_SIZE / 2,
                            y * TILE_SIZE + TILE_SIZE / 2,
                            2,
                            0,
                            Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }
        }

        // æ¸²æŸ“åƒè±†äºº
        function renderPacman() {
            const centerX = pacman.pixelX + TILE_SIZE / 2;
            const centerY = pacman.pixelY + TILE_SIZE / 2;
            const radius = TILE_SIZE * 0.4;

            ctx.save();
            ctx.translate(centerX, centerY);

            // æ—‹è½¬æ ¹æ®æ–¹å‘
            const rotations = {
                'right': 0,
                'down': Math.PI / 2,
                'left': Math.PI,
                'up': -Math.PI / 2
            };
            ctx.rotate(rotations[pacman.direction]);

            // èƒ½é‡å…‰ç¯
            if (pacman.powered) {
                ctx.strokeStyle = 'rgba(255, 105, 180, 0.5)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, radius * 1.5, 0, Math.PI * 2);
                ctx.stroke();
            }

            // é»„è‰²èº«ä½“ï¼ˆå˜´å·´åŠ¨ç”»ï¼‰
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            const mouthSize = Math.abs(Math.sin(pacman.mouthAngle)) * 0.4;
            ctx.arc(0, 0, radius, mouthSize, Math.PI * 2 - mouthSize);
            ctx.lineTo(0, 0);
            ctx.fill();

            // ç²‰è‰²è´è¶ç»“
            ctx.fillStyle = '#ff69b4';
            const bowY = -radius * 0.7;
            const bowSize = radius * 0.3;

            // å·¦è¾¹ä¸‰è§’å½¢
            ctx.beginPath();
            ctx.moveTo(-bowSize, bowY);
            ctx.lineTo(-bowSize * 0.3, bowY - bowSize * 0.5);
            ctx.lineTo(-bowSize * 0.3, bowY + bowSize * 0.5);
            ctx.fill();

            // å³è¾¹ä¸‰è§’å½¢
            ctx.beginPath();
            ctx.moveTo(bowSize, bowY);
            ctx.lineTo(bowSize * 0.3, bowY - bowSize * 0.5);
            ctx.lineTo(bowSize * 0.3, bowY + bowSize * 0.5);
            ctx.fill();

            // ä¸­é—´åœ†ç‚¹
            ctx.beginPath();
            ctx.arc(0, bowY, bowSize * 0.2, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }

        // æ¸²æŸ“é¬¼é­‚
        function renderGhost(ghost) {
            const centerX = ghost.pixelX + TILE_SIZE / 2;
            const centerY = ghost.pixelY + TILE_SIZE / 2;
            const radius = TILE_SIZE * 0.4;

            if (ghost.respawnTimer > 0) return; // ä¸æ¸²æŸ“æ­£åœ¨å¤æ´»çš„é¬¼é­‚

            if (ghost.mode === 'eaten') {
                // åªç”»çœ¼ç›
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.2, 0, Math.PI * 2);
                ctx.arc(centerX + radius * 0.3, centerY - radius * 0.2, radius * 0.2, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.1, 0, Math.PI * 2);
                ctx.arc(centerX + radius * 0.3, centerY - radius * 0.2, radius * 0.1, 0, Math.PI * 2);
                ctx.fill();
                return;
            }

            // é¬¼é­‚èº«ä½“
            ctx.fillStyle = ghost.color;
            ctx.beginPath();
            ctx.arc(centerX, centerY - radius * 0.3, radius, Math.PI, 0);
            ctx.lineTo(centerX + radius, centerY + radius);

            // æ³¢æµªåº•éƒ¨
            const waves = 3;
            for (let i = 0; i < waves; i++) {
                ctx.lineTo(
                    centerX + radius - (i + 0.5) * (radius * 2 / waves),
                    centerY + radius - radius * 0.3
                );
                ctx.lineTo(
                    centerX + radius - (i + 1) * (radius * 2 / waves),
                    centerY + radius
                );
            }

            ctx.closePath();
            ctx.fill();

            // çœ¼ç›
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath();
            ctx.arc(centerX - radius * 0.3, centerY - radius * 0.2, radius * 0.3, 0, Math.PI * 2);
            ctx.arc(centerX + radius * 0.3, centerY - radius * 0.2, radius * 0.3, 0, Math.PI * 2);
            ctx.fill();

            // ç³å­”
            ctx.fillStyle = '#000000';
            const eyeOffsetX = DIRECTIONS[ghost.direction].x * radius * 0.15;
            const eyeOffsetY = DIRECTIONS[ghost.direction].y * radius * 0.15;
            ctx.beginPath();
            ctx.arc(centerX - radius * 0.3 + eyeOffsetX, centerY - radius * 0.2 + eyeOffsetY, radius * 0.15, 0, Math.PI * 2);
            ctx.arc(centerX + radius * 0.3 + eyeOffsetX, centerY - radius * 0.2 + eyeOffsetY, radius * 0.15, 0, Math.PI * 2);
            ctx.fill();
        }

        // æ¸²æŸ“ç«ç‘°
        function renderRose() {
            if (!rose.active) return;

            const x = rose.gridX * TILE_SIZE + TILE_SIZE / 2;
            const y = rose.gridY * TILE_SIZE + TILE_SIZE / 2;

            // å‘å…‰æ•ˆæœ
            const glow = Math.sin(rose.glowPhase) * 0.3 + 0.7;
            ctx.save();
            ctx.shadowBlur = 15 * glow;
            ctx.shadowColor = '#ff1493';

            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ğŸŒ¹', x, y);

            ctx.restore();
        }

        // æ¸²æŸ“å¿ƒå½¢
        function renderHearts() {
            hearts.forEach(heart => {
                // æ‹–å°¾
                heart.trail.forEach((pos, i) => {
                    const alpha = 1 - (i / heart.trail.length);
                    ctx.fillStyle = `rgba(255, 105, 180, ${alpha * 0.3})`;
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('â¤ï¸', pos.x, pos.y);
                });

                // ä¸»ä½“
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff1493';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('â¤ï¸', heart.pixelX, heart.pixelY);
                ctx.restore();
            });
        }

        // æ¸²æŸ“å¼€å§‹å±å¹•
        function renderStartScreen() {
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ff69b4';
            ctx.font = '24px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('Pac-Man:', canvas.width / 2, 130);
            ctx.fillText('Valentine\'s Edition', canvas.width / 2, 170);

            ctx.fillStyle = '#e0e0f0';
            ctx.font = '14px "Press Start 2P"';
            ctx.fillText('Press ENTER', canvas.width / 2, 250);
            ctx.fillText('or Click to Start', canvas.width / 2, 280);

            ctx.font = '10px "Press Start 2P"';
            ctx.fillStyle = '#00f0ff';
            ctx.fillText('Arrow keys to move', canvas.width / 2, 350);
            ctx.fillText('Eat all pellets', canvas.width / 2, 380);
            ctx.fillText('Avoid ghosts', canvas.width / 2, 410);
            ctx.fillText('Collect roses for power!', canvas.width / 2, 440);
        }

        // æ¸²æŸ“æ¸¸æˆç»“æŸå±å¹•
        function renderGameOverScreen() {
            ctx.fillStyle = 'rgba(10, 10, 18, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ff1493';
            ctx.font = '32px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 50);

            ctx.fillStyle = '#e0e0f0';
            ctx.font = '16px "Press Start 2P"';
            ctx.fillText('Final Score: ' + gameState.score, canvas.width / 2, canvas.height / 2 + 20);

            ctx.font = '12px "Press Start 2P"';
            ctx.fillStyle = '#00f0ff';
            ctx.fillText('Press ENTER', canvas.width / 2, canvas.height / 2 + 70);
            ctx.fillText('or Click to Restart', canvas.width / 2, canvas.height / 2 + 95);
        }

        // æ¸²æŸ“èƒœåˆ©å±å¹•
        function renderWinScreen() {
            ctx.fillStyle = 'rgba(10, 10, 18, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#ff69b4';
            ctx.font = '32px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('You Win!', canvas.width / 2, canvas.height / 2 - 50);

            ctx.fillStyle = '#e0e0f0';
            ctx.font = '16px "Press Start 2P"';
            ctx.fillText('Final Score: ' + gameState.score, canvas.width / 2, canvas.height / 2 + 20);

            ctx.font = '12px "Press Start 2P"';
            ctx.fillStyle = '#00f0ff';
            ctx.fillText('Press ENTER', canvas.width / 2, canvas.height / 2 + 70);
            ctx.fillText('or Click to Play Again', canvas.width / 2, canvas.height / 2 + 95);
        }

        // æ¸²æŸ“æš‚åœå±å¹•
        function renderPausedScreen() {
            // åŠé€æ˜é®ç½©
            ctx.fillStyle = 'rgba(10, 10, 18, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#00f0ff';
            ctx.font = '32px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 40);

            ctx.fillStyle = '#e0e0f0';
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('Press P or ESC', canvas.width / 2, canvas.height / 2 + 20);
            ctx.fillText('to Resume', canvas.width / 2, canvas.height / 2 + 45);

            ctx.fillStyle = '#ff69b4';
            ctx.font = '12px "Press Start 2P"';
            ctx.fillText('Press Q to Quit', canvas.width / 2, canvas.height / 2 + 85);
        }

        // æ¸¸æˆå¾ªç¯
        function gameLoop(timestamp) {
            const deltaTime = timestamp - gameState.lastTime;
            gameState.lastTime = timestamp;

            if (gameState.screen === 'start') {
                renderStartScreen();
            } else if (gameState.screen === 'playing') {
                // æ›´æ–°
                updatePacman(deltaTime);
                ghosts.forEach(ghost => updateGhost(ghost, deltaTime));
                updateRose(deltaTime);
                updateHearts(deltaTime);
                checkCollisions();
                updateUI();

                // æ¸²æŸ“
                ctx.fillStyle = '#0a0a12';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                renderMaze();
                renderPellets();
                renderRose();
                renderHearts();
                ghosts.forEach(ghost => renderGhost(ghost));
                renderPacman();

                // æ˜¾ç¤ºå¿«æ·é”®æç¤º
                ctx.fillStyle = 'rgba(224, 224, 240, 0.5)';
                ctx.font = '12px Rajdhani';
                ctx.textAlign = 'right';
                ctx.fillText('[P] Pause  [Q] Quit', canvas.width - 10, 20);

            } else if (gameState.screen === 'paused') {
                // å…ˆæ¸²æŸ“æ¸¸æˆç”»é¢ï¼ˆé™æ­¢ï¼‰
                ctx.fillStyle = '#0a0a12';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                renderMaze();
                renderPellets();
                renderRose();
                renderHearts();
                ghosts.forEach(ghost => renderGhost(ghost));
                renderPacman();

                // ç„¶åæ¸²æŸ“æš‚åœé®ç½©
                renderPausedScreen();

            } else if (gameState.screen === 'gameover') {
                renderGameOverScreen();
            } else if (gameState.screen === 'win') {
                renderWinScreen();
            }

            gameState.frame++;
            requestAnimationFrame(gameLoop);
        }

        // å¯åŠ¨æ¸¸æˆ
        init();
    </script>
</body>
</html>
